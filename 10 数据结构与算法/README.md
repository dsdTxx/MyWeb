# 数据结构与算法
# 为什么学习数据结构与算法

# 如何学习——抓重点

### 数据结构同算法的关系

数据结构与算法相辅相成，数据结构为算法服务的，算法要在特定的数据结构之上，两者无法孤立。

数据结构是静态的，是数据组织、存储的一种方式。

### 重点

* **时间及空间复杂度分析**
* 数据结构：堆、栈、数组、链表、队列、散列表、二叉树、跳表、图、Trie树
* 算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规则、字符串匹配算法

### 学习方法

* **学习来历，自身特点，适合解决的问题及实际的应用场景**
* **适度刷题，边学边练**
* 多思考，多互动
* 打怪升级法，设定小目标，多发朋友圈，让大家监督
* 知识需要沉淀，不要试图一下子掌握所有，要反复迭代，不断沉淀
* 不要只抓住一点，一直看，耗费太多时间，先整体过一遍，有个整体的印象，再细看。

# 复杂度分析

### 是什么

时间复杂度分析包括**时间复杂度**和**空间复杂度**

**时间复杂度**:随着数据规模n的增大，执行方法所消耗的时间的函数。

**空间复杂度**：随着数据规模n的增大，执行方法所占用的空间的函数关系式。

复杂度分析：是一种粗略的分析，主要看的是趋势，**渐进复杂度分析**

### 为什么

* 事后统计虽然准确，受限制太多，不一定具备环境
* 测试结果十分依赖测试环境，同电脑配置紧密相关
* 测试结果受数据规模影响很大，不同的量级的n,执行结果可能完全不一样

### 大O复杂度表示法

* unit_time 每行代码执行的时间
* 忽略常量，低阶、系数忽略，n无限大时对增长趋势的变化影响很小，可以忽略不记
* 只关注代码执行次数最多的几行代码即可，对增长影响最大
* **加法法则**: 总复杂度等于两级最大的那段代码的复杂度
* **乘法法则：**嵌套代码的复杂度为嵌套内外代码复杂度的乘积
* 如果受多个参数影响 m,n，因为m,n的大小关系不确定，O（m+n）

### O(1)

```:zap:
 int i = 8;
 int j = 6;
 int sum = i + j;
```

代码执行时间不随n增大，不管多少行代码，复杂度都是O(1)

### O(n)

```:zzz:
int sum_1 = 0;
int p = 1;
for (; p < n; ++p) {
	sum_1 = sum_1 + p;       // n
}
```

* t表示unit_time
* 前两行2t,循环部分2nt
* 假设t是固定的，fn(2+2n),n增加很大时，常量和系数影响可以忽略，所以是 O(n)

### O(n<sup>2</sup>)

```:new_zealand:
int cal(int n) {
   int ret = 0; 
   int i = 1;
   for (; i < n; ++i) {
     ret = ret + f(i);      O(n) 
   } 
 } 
 
 int f(int n) {        //O(n)
  int sum = 0;
  int i = 1;
  for (; i < n; ++i) {
    sum = sum + i;
  } 
  return sum;
 }
```

* 外层O(n)
* 外层每执行一次，内层就执行n次  O(n)
* 总共执行n<sup>2</sup>次
* 嵌套循环 乘法法则 O(n<sup>2</sup>)=T1(n)*T2(n)

### O(logn)  O(nlogn)

```:zero:
 i=1;
 while (i <= n)  {
   i = i * 2;
 }
```

求循环执行多少次,根据高中数学，i 1 2 4 8...，所以是求下图中的x

![0对数计算](imgs\0对数计算.jpg)2<sup>x</sup>=n,所以执行次数x=log<sub>2</sub>n,所以时间复杂度是O(log<sub>2</sub>n) 
找规律，再看下面代码

```c#
 i=1;
 while (i <= n)  {
   i = i * 3;
 }
```

3 9 27   3<sup>x</sup>=n,所以执行次数x=log<sub>3</sub>n,
因为log<sub>3</sub>n = log<sub>3</sub>2 * log<sub>2</sub>n,忽略系数，所以时间复杂度为O(logn),执行若外层嵌套，执行n次，则为O(nlogn)

